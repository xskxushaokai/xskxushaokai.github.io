<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据结构与基础算法（C++版）</title>
    <!-- 引入Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Font Awesome -->
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- 引入KaTeX数学公式支持 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <!-- 引入Prism.js语法高亮 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    
    <!-- 配置Tailwind -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#165DFF',
                        secondary: '#36CFC9',
                        dark: '#1D2129',
                        light: '#F2F3F5',
                        accent: '#FF7D00'
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif'],
                        mono: ['Consolas', 'Monaco', 'monospace']
                    }
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .nav-active {
                @apply bg-primary/10 text-primary border-l-4 border-primary;
            }
            .transition-nav {
                @apply transition-all duration-300 ease-in-out;
            }
            .markdown-content h1 {
                @apply text-3xl font-bold mb-6 mt-8 text-primary border-b-2 border-primary pb-2;
            }
            .markdown-content h2 {
                @apply text-2xl font-bold mb-4 mt-6 text-dark;
            }
            .markdown-content h3 {
                @apply text-xl font-semibold mb-3 mt-5 text-dark;
            }
            .markdown-content p {
                @apply text-gray-700 mb-4 leading-relaxed;
            }
            .markdown-content code {
                @apply bg-gray-100 text-red-600 px-1 py-0.5 rounded text-sm font-mono;
            }
            .markdown-content pre {
                @apply bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto mb-4;
            }
            /* 移除对代码块内code元素的样式覆盖，让Prism.js接管语法高亮 */
            .markdown-content pre code {
                @apply bg-transparent p-0;
                color: inherit !important;
                background: transparent !important;
            }
            .markdown-content ul, .markdown-content ol {
                @apply mb-4 pl-6;
            }
            .markdown-content li {
                @apply text-gray-700 mb-1;
            }
            .markdown-content blockquote {
                @apply border-l-4 border-primary pl-4 italic text-gray-600 mb-4;
            }
            .markdown-content table {
                @apply w-full border-collapse mb-4;
            }
            .markdown-content th, .markdown-content td {
                @apply border border-gray-300 px-4 py-2;
            }
            .markdown-content th {
                @apply bg-gray-100 font-semibold;
            }
            .markdown-content a {
                @apply text-primary hover:underline;
            }
            .markdown-content img {
                @apply max-w-full h-auto mb-4 rounded-lg shadow-md;
            }
            .markdown-content hr {
                @apply my-8 border-t-2 border-gray-300;
            }
            /* KaTeX样式优化 */
            .katex {
                font-size: 1.1em !important;
            }
            .katex-display {
                margin: 1em 0 !important;
            }
        }
    </style>
</head>
<body class="bg-gray-50 font-sans text-dark fixed-layout">
    <div class="flex h-full">
        <!-- 侧边导航栏 -->
        <aside id="sidebar" class="w-64 bg-white shadow-lg z-10 hidden md:block transition-nav fixed-sidebar">
            <!-- 网站标题 -->
            <div class="p-6 border-b border-gray-200">
                <h1 class="text-xl font-bold text-primary flex items-center">
                    <i class="fa fa-code-fork mr-3"></i>
                    数据结构与算法
                </h1>
                <p class="text-sm text-gray-500 mt-1">C++版教程</p>
            </div>
            
            <!-- 导航菜单 -->
            <nav class="p-4">
                <ul class="space-y-1">
                    <li>
                        <a href="index.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-home w-5 text-center mr-3"></i>
                            首页
                        </a>
                    </li>
                    <li>
                        <a href="ch1.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-info-circle w-5 text-center mr-3"></i>
                            第一章：算法基础
                        </a>
                    </li>
                    <li>
                        <a href="list.html" class="nav-active flex items-center px-4 py-3 text-sm rounded-lg transition-nav">
                            <i class="fa fa-list w-5 text-center mr-3"></i>
                            第二章：链表
                        </a>
                    </li>
                    <li>
                        <a href="ch3.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-stack-overflow w-5 text-center mr-3"></i>
                            第三章：栈与队列
                        </a>
                    </li>
                    <li>
                        <a href="ch4.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-link w-5 text-center mr-3"></i>
                            第四章：串
                        </a>
                    </li>
                    <li>
                        <a href="ch5.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-sitemap w-5 text-center mr-3"></i>
                            第五章：树与二叉树
                        </a>
                    </li>
                    <li>
                        <a href="ch6.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-share-alt w-5 text-center mr-3"></i>
                            第六章：图
                        </a>
                    </li>
                    <li>
                        <a href="ch7.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-search w-5 text-center mr-3"></i>
                            第七章：查找
                        </a>
                    </li>
                    <li>
                        <a href="ch8.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-sort w-5 text-center mr-3"></i>
                            第八章：排序
                        </a>
                    </li>
                    <li>
                        <a href="ch9.html" class="flex items-center px-4 py-3 text-sm text-gray-700 hover:bg-gray-100 rounded-lg transition-nav">
                            <i class="fa fa-code w-5 text-center mr-3"></i>
                            第九章：综合实例
                        </a>
                    </li>
                </ul>
            </nav>
        </aside>
        
        <!-- 主内容区 -->
        <main class="flex-1 flex flex-col">
            <!-- 顶部导航 -->
            <header class="bg-white shadow-sm py-4 px-6 flex-shrink-0">
                <button id="menu-toggle" class="md:hidden text-gray-600 focus:outline-none">
                    <i class="fa fa-bars text-xl"></i>
                </button>
                <div class="text-lg font-medium text-gray-800">数据结构与基础算法（C++版）</div>
                <div class="flex items-center space-x-4">
                    <button class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fa fa-search text-lg"></i>
                    </button>
                    <button class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fa fa-user-circle text-lg"></i>
                    </button>
                </div>
            </header>
            
            <!-- 内容区域 -->
            <div class="fixed-content p-6 md:p-10 bg-gray-50">
                <div class="max-w-4xl mx-auto">
                    <!-- 链表教学内容 -->
                    <div class="markdown-content bg-white rounded-xl p-8 shadow-lg">
                        <h1 id="链表">链表</h1>
                        
                        <h2 id="引入">引入</h2>
                        <p>链表的特点是：用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以不连续）。通过如链条一般的指针来连接元素。它的特点是插入与删除数据十分方便，但寻找与读取数据的表现欠佳。常用的链表操作有：初始化、添加、遍历、插入、删除、查找、排序、释放等。链表可分为<strong>单向链表</strong>和<strong>双向链表</strong>，如图所示：</p>
                        <p><img alt="输入图片说明" src="./images/82be4f10-909b-406d-8b8f-212c680b2c4a.svg">
                        （a）单向链表<br><br>
                        <img alt="输入图片说明" src="./images/9c7ec030-b0d3-4428-8991-330ccd7c6666.png">
                        （b）双向链表</p>
                        <p>链表一般是循环的，各节点首尾相接，最后的next指针指向第1个节点，第1个pre指针指向最后一个节点。单向链表只有一个遍历方向，双向链表有两个遍历方向，比单向链表的访问更方便一些，也快一些。在需要频繁访问前后几个节点的场景可以使用双向链表。</p>
                        <p>使用链表时，可以直接用STL list，也可以自己写链表。如果自己写代码实现链表，有两种编码实现方法：<strong>动态链表</strong> 和 <strong>静态链表</strong>。在算法竞赛中为加快编码速度，一般使用静态链表或STL list。而在工程应中，为进行高效的空间管理，通常使用动态链表。</p>
                        <p>下面用例题洛谷 P1996，给出动态链表、静态链表、STL 链表等 4 种实现方案。</p>
                        
                        <h2 id="与数组的区别">与数组的区别</h2>
                        <p>链表和数组都可用于存储数据。与链表不同，数组将所有元素按次序依次存储。不同的存储结构令它们有了不同的优势：</p>
                        <p>链表因其链状的结构，能方便地删除、插入数据，操作次数是 $O(1)$。但也因为这样，寻找、读取数据的效率不如数组高，在随机访问数据中的操作次数是 $O(n)$</p>
                        <p>数组可以方便地寻找并读取数据，在随机访问中操作次数是 $O(1)$但删除、插入的操作次数是 $O(n)$次。</p>
                        
                        <hr>
                        
                        <h2 id="例题-约瑟夫问题（洛谷p1996）">例题  约瑟夫问题（洛谷P1996）</h2>
                        <p><strong>题目描述</strong><br>
                        $n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。</p>
                        <p><strong>输入格式</strong>：输入两个整数 $n,m$。<br>
                        <strong>输出格式</strong>：输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。</p>
                        <p><strong>输入样例</strong></p>
                        <pre><code>10 3</code></pre>
                        <p><strong>输出样例</strong></p>
                        <pre><code>3 6 9 2 7 1 8 5 10 4</code></pre>
                        <p><strong>说明/提示</strong><br>
                        $1 \le m, n \le 100$</p>
                        
                        <hr>
                        
                        <h2 id="动态链表">动态链表</h2>
                        <p>动态链表需要临时分配链表节点、使用完毕后释放链表节点。这样做，优点是能及时释放空间，不使用多余内存。缺点是很容易出错。动态链表是"教科书式"的标准做法。<br>
                        以下代码用动态单向链表实现 P1996</p>
                        <pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

struct node{
    //链表结构
    int data;
    node *next;
};

int main(){
    int n,m;
    scanf("%d %d",&n,&m);
    node *head,*p,*now,*prev;
    //定义变量
    head = new node; head-&gt;data = 1; head-&gt;next=NULL; //分配第一个节点，数据置为 1
    now = head; //当前指针是头
    for(int i=2;i&lt;=n;i++){
        p = new node;
        p-&gt;data = i; p-&gt;next = NULL;//p 是新节点
        now-&gt;next = p;//把申请的新节点连到前面的链表上
        now = p;//尾指针后移一个
    }
    now-&gt;next = head;//尾指针指向头：循环链表建立完成

    // 模拟题目流程
    now = head, prev=head;  //从第 1 个开始数
    while((n--) ){
        for(int i=1;i&lt;m;i++){    //数到 m，停下
            prev = now;    //记录上一个位置，用于下面跳过第 m 个节点
            now = now-&gt;next;
        }
        printf("%d ", now-&gt;data);    //输出第 m 节点，带空格
        prev-&gt;next = now-&gt;next;    //跳过这个节点
        delete now;    //释放节点
        now = prev-&gt;next;    //新的一轮
    }

    return 0;
}</code></pre>
                        
                        <h2 id="静态链表">静态链表</h2>
                        <p><strong>动态链表虽然标准，但是竞赛中一般不用。算法竞赛对内存管理要求不严格，为加快编码速度，一般就在题目允许的存储空间内静态分配内存，省去了动态分配内存和释放的麻烦。</strong></p>
                        <p>静态链表使用预先分配的一段连续空间存储链表。具体做法为：定义链表结构体数组，和动态链表的结构差不多。以下给出两个示例，分别是：用结构体数组实现单向静态链表、用结构体数组实现双向静态链表。</p>
                        <p>1.<strong>用结构体数组实现单向静态链表</strong>，注意静态分配尽量定义在全局，而不要定义在函数内部。</p>
                        <pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

const int maxn = 105;//定义静态链表的空间大小

struct node{
    //单向链表
    int data;  // 数据域
    int nextid;  // 指针域
}nodes[maxn];

int main(){
    int n, m;
    scanf("%d%d", &n, &m);
    
    // 链表初始化
    for(int i = 1; i &lt;= n; i++){
        nodes[i].data = i;
        nodes[i].nextid = i + 1;
    }
    nodes[n].nextid = 1;//循环链表：尾指向头

    int now = 1, prev = 1;//从第 1 个开始报数
    while(n--){
        for(int i = 1; i &lt; m; i++){//数到 m，停下
            prev = now;
            now = nodes[now].nextid;
        }
        printf("%d ", nodes[now].data);
        nodes[prev].nextid = nodes[now].nextid;//跳过节点 now，即删除 now
        now = nodes[prev].nextid;//新的 now
    }

    return 0;
}</code></pre>
                        
                        <p>2.<strong>用结构体数组实现双向静态链表</strong></p>
                        <pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

const int maxn = 105;

struct node{
    //双向链表
    int data; // 数据域
    int preid;// 指针域，前一个节点
    int nextid;// 指针域，后一个节点
}nodes[maxn];

int main(){
    int n, m;
    scanf("%d%d", &n, &m);

    //建立链表
    for(int i = 1; i &lt;= n; i++){
        nodes[i].data = i;
        nodes[i].preid = i-1;//前节点
        nodes[i].nextid = i+1;//后节点
    }
    nodes[n].nextid = 1;//循环链表：尾指向头
    nodes[1].preid = n;//循环链表：头指向尾

    int now = 1;//从第 1 个开始
    while(n--){
        for(int i = 1; i &lt; m; i++)//数到 m，停下
            now = nodes[now].nextid;
        printf("%d ", nodes[now].data);//打印
        
        // 删除now节点
        int prev = nodes[now].preid;  // 先将now节点的前、后两个节点取出
        int next = nodes[now].nextid;
        nodes[prev].nextid = nodes[now].nextid;//删除 now
        nodes[next].preid = nodes[now].preid;
        
        now = next;//新的开始
    }
    
    return 0;
}</code></pre>
                        
                        <hr>
                        
                        <h2 id="stl-list">STL list</h2>
                        <p>竞赛或工程中，常常使用 C++ STL list。list 是双向链表，它的内存空间可以是不连续的，通过指针来进行数据的访问，它能高效率地在任意地方删除和插入，插入和删除操作是常数时间的。
                        有关STL list的具体用法，可查看<a href="https://www.cnblogs.com/linuxAndMcu/p/10260627.html">https://www.cnblogs.com/linuxAndMcu/p/10260627.html</a></p>
                        <p>下面是使用list实现 P1996</p>
                        <pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;

using namespace std;

int main(){
    int n, m;
    cin&gt;&gt;n&gt;&gt;m;

    list&lt;int&gt;node;
    for(int i=1;i&lt;=n;i++)
        //建立链表
        node.push_back(i);
        
    list&lt;int&gt;::iterator it = node.begin();
    while(node.size()){    //list 的大小由 STL 自己管理
        for(int i=1;i&lt;m;i++){    //数到 m
            it++;
            if(it == node.end()) //手动循环链表，end()是 list 末端下一位置
                it = node.begin();
        }

        cout &lt;&lt; *it &lt;&lt;' ';
        // 先取出下一个节点
        list&lt;int&gt;::iterator next = ++it;
        if(next==node.end())
            next=node.begin();    //手动循环链表
        // 删除报m的节点，node.size()自动减 1
        node.erase(--it);
        // 下一轮报数从下一个节点开始
        it = next;

    }
    
    return 0;
}</code></pre>
                        
                        <hr>
                        
                        <h2 id="附-动态链表常用的实现">附 动态链表常用的实现</h2>
                        
                        <h3 id="双向链表">双向链表</h3>
                        <pre><code class="language-c++">struct Node {
  int value;
  Node *left;
  Node *right;
};</code></pre>
                        
                        <h3 id="向双向循环链表中插入（写入）数据">向双向循环链表中插入（写入）数据</h3>
                        <p>在向双向循环链表插入数据时，除了要判断给定链表是否为空外，还要同时修改左、右两个指针。</p>
                        <p>大致流程如下：</p>
                        <ol>
                        <li>初始化待插入的数据 <code>node</code>；</li>
                        <li>判断给定链表 <code>p</code> 是否为空；</li>
                        <li>若为空，则将 <code>node</code> 的 <code>left</code> 和 <code>right</code> 指针，以及 <code>p</code> 都指向自己；</li>
                        <li>否则，将 <code>node</code> 的 <code>left</code> 指针指向 <code>p</code>;</li>
                        <li>将 <code>node</code> 的 <code>right</code> 指针指向 <code>p</code> 的右结点；</li>
                        <li>将 <code>p</code> 右结点的 <code>left</code> 指针指向 <code>node</code>；</li>
                        <li>将 <code>p</code> 的 <code>right</code> 指针指向 <code>node</code>。</li>
                        </ol>
                        <pre><code class="language-c++">void insertNode(int i, Node *p) {
    Node *node = new Node;
    node-&gt;value = i;
    if (p == NULL) {
        p = node;
        node-&gt;left = node;
        node-&gt;right = node;
    } 
    else {
        node-&gt;left = p;
        node-&gt;right = p-&gt;right;
        p-&gt;right-&gt;left = node;
        p-&gt;right = node;
    }
}</code></pre>
                        
                        <h3 id="从双向循环链表中删除数据">从双向循环链表中删除数据</h3>
                        <p>流程大致如下：</p>
                        <ol>
                        <li>将 <code>p</code> 左结点的右指针指向 <code>p</code> 的右节点；</li>
                        <li>将 <code>p</code> 右结点的左指针指向 <code>p</code> 的左节点；</li>
                        <li>新建一个临时结点 <code>t</code> 存放 <code>p</code> 的地址；</li>
                        <li>将 <code>p</code> 的右节点地址赋给 <code>p</code>，以避免 <code>p</code> 变成悬垂指针；</li>
                        <li>删除 <code>t</code>。</li>
                        </ol>
                        <pre><code class="language-c++">void deleteNode(Node *&amp;p) {
    p-&gt;left-&gt;right = p-&gt;right;
    p-&gt;right-&gt;left = p-&gt;left;
    Node *t = p;
    p = p-&gt;right;
    delete t;
}</code></pre>
                    </div>
                </div>
            </div>
            <!-- 页脚 -->
            <footer class="bg-white border-t border-gray-200 py-4 px-6 text-center text-gray-500 text-sm flex-shrink-0">
                <p>© 2025 数据结构与基础算法（C++版）教程 | powered by xsk</p>
            </footer>
        </main>
    </div>
            <!-- 页脚 -->
            <footer class="bg-white border-t border-gray-200 py-4 px-6 text-center text-gray-500 text-sm flex-shrink-0">
                <p>© 2025 数据结构与基础算法（C++版）教程 | powered by xsk</p>
            </footer>
        </main>
    </div>
    
    <!-- 移动端侧边栏遮罩 -->
    <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-10 hidden md:hidden"></div>
    
    <script>
        // 移动端侧边栏切换
        const menuToggle = document.getElementById('menu-toggle');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        
        menuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('hidden');
            sidebar.classList.toggle('absolute');
            sidebar.classList.toggle('top-0');
            sidebar.classList.toggle('left-0');
            sidebar.classList.toggle('h-full');
            sidebarOverlay.classList.toggle('hidden');
        });
        
        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.add('hidden');
            sidebar.classList.remove('absolute', 'top-0', 'left-0', 'h-full');
            sidebarOverlay.classList.add('hidden');
        });
        
        // 导航链接点击事件（移动端）
        const navLinks = document.querySelectorAll('nav a');
        navLinks.forEach(link => {
            link.addEventListener('click', () => {
                if (window.innerWidth < 768) {
                    sidebar.classList.add('hidden');
                    sidebar.classList.remove('absolute', 'top-0', 'left-0', 'h-full');
                    sidebarOverlay.classList.add('hidden');
                }
            });
        });
        
        // 滚动效果
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                if (targetId !== 'index.html') return;
                
                const targetElement = document.querySelector(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({
                        behavior: 'smooth'
                    });
                }
            });
        });
        
        // KaTeX数学公式渲染和Prism.js语法高亮
        document.addEventListener('DOMContentLoaded', function() {
            // 渲染页面中的数学公式
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\(', right: '\\)', display: false},
                        {left: '\\[', right: '\\]', display: true}
                    ],
                    throwOnError: false
                });
            }
            
            // 初始化Prism.js语法高亮
            if (typeof Prism !== 'undefined') {
                // 手动高亮所有代码块
                document.querySelectorAll('pre code').forEach((block) => {
                    Prism.highlightElement(block);
                });
            }
        });
    </script>
    
    <!-- 引入KaTeX -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</body>
</html>

<style type="text/tailwindcss">
    @layer utilities {
        .content-auto {
            content-visibility: auto;
        }
        .nav-active {
            @apply bg-primary/10 text-primary border-l-4 border-primary;
        }
        .transition-nav {
            @apply transition-all duration-300 ease-in-out;
        }
        .markdown-content h1 {
            @apply text-3xl font-bold mb-6 mt-8 text-primary border-b-2 border-primary pb-2;
        }
        .markdown-content h2 {
            @apply text-2xl font-bold mb-4 mt-6 text-dark;
        }
        .markdown-content h3 {
            @apply text-xl font-semibold mb-3 mt-5 text-dark;
        }
        .markdown-content p {
            @apply text-gray-700 mb-4 leading-relaxed;
        }
        .markdown-content code {
            @apply bg-gray-100 text-red-600 px-1 py-0.5 rounded text-sm font-mono;
        }
        .markdown-content pre {
            @apply bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto mb-4;
        }
        /* 移除对代码块内code元素的样式覆盖，让Prism.js接管语法高亮 */
        .markdown-content pre code {
            @apply bg-transparent p-0;
            color: inherit !important;
            background: transparent !important;
        }
        .markdown-content ul, .markdown-content ol {
            @apply mb-4 pl-6;
        }
        .markdown-content li {
            @apply text-gray-700 mb-1;
        }
        .markdown-content blockquote {
            @apply border-l-4 border-primary pl-4 italic text-gray-600 mb-4;
        }
        .markdown-content table {
            @apply w-full border-collapse mb-4;
        }
        .markdown-content th, .markdown-content td {
            @apply border border-gray-300 px-4 py-2;
        }
        .markdown-content th {
            @apply bg-gray-100 font-semibold;
        }
        .markdown-content a {
            @apply text-primary hover:underline;
        }
        .markdown-content img {
            @apply max-w-full h-auto mb-4 rounded-lg shadow-md;
        }
        .markdown-content hr {
            @apply my-8 border-t-2 border-gray-300;
        }
        /* KaTeX样式优化 */
        .katex {
            font-size: 1.1em !important;
        }
        .katex-display {
            margin: 1em 0 !important;
        }
        /* 固定布局样式 */
        .fixed-layout {
            height: 100vh;
            overflow: hidden;
        }
        .fixed-sidebar {
            height: 100vh;
            overflow-y: auto;
        }
        .fixed-content {
            height: calc(100vh - 64px - 64px); /* 减去顶部导航和页脚的高度 */
            overflow-y: auto;
        }
    }
</style>